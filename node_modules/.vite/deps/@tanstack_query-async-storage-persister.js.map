{
  "version": 3,
  "sources": ["../../@tanstack/query-async-storage-persister/src/utils.ts", "../../@tanstack/query-async-storage-persister/src/asyncThrottle.ts", "../../@tanstack/query-async-storage-persister/src/index.ts"],
  "sourcesContent": ["export function noop(): void\nexport function noop(): undefined\nexport function noop() {}\n", "import { noop } from './utils'\n\ninterface AsyncThrottleOptions {\n  interval?: number\n  onError?: (error: unknown) => void\n}\n\nexport function asyncThrottle<TArgs extends ReadonlyArray<unknown>>(\n  func: (...args: TArgs) => Promise<void>,\n  { interval = 1000, onError = noop }: AsyncThrottleOptions = {},\n) {\n  if (typeof func !== 'function') throw new Error('argument is not function.')\n\n  let nextExecutionTime = 0\n  let lastArgs = null\n  let isExecuting = false\n  let isScheduled = false\n\n  return async (...args: TArgs) => {\n    lastArgs = args\n    if (isScheduled) return\n    isScheduled = true\n    while (isExecuting) {\n      await new Promise((done) => setTimeout(done, interval))\n    }\n    while (Date.now() < nextExecutionTime) {\n      await new Promise((done) =>\n        setTimeout(done, nextExecutionTime - Date.now()),\n      )\n    }\n    isScheduled = false\n    isExecuting = true\n    try {\n      await func(...lastArgs)\n    } catch (error) {\n      try {\n        onError(error)\n      } catch {}\n    }\n    nextExecutionTime = Date.now() + interval\n    isExecuting = false\n  }\n}\n", "import { asyncThrottle } from './asyncThrottle'\nimport { noop } from './utils'\nimport type {\n  AsyncStorage,\n  MaybePromise,\n  PersistedClient,\n  Persister,\n  Promisable,\n} from '@tanstack/query-persist-client-core'\n\nexport type AsyncPersistRetryer = (props: {\n  persistedClient: PersistedClient\n  error: Error\n  errorCount: number\n}) => Promisable<PersistedClient | undefined>\n\ninterface CreateAsyncStoragePersisterOptions {\n  /** The storage client used for setting and retrieving items from cache.\n   * For SSR pass in `undefined`. Note that window.localStorage can be\n   * `null` in Android WebViews depending on how they are configured.\n   */\n  storage: AsyncStorage<string> | undefined | null\n  /** The key to use when storing the cache */\n  key?: string\n  /** To avoid spamming,\n   * pass a time in ms to throttle saving the cache to disk */\n  throttleTime?: number\n  /**\n   * How to serialize the data to storage.\n   * @default `JSON.stringify`\n   */\n  serialize?: (client: PersistedClient) => MaybePromise<string>\n  /**\n   * How to deserialize the data from storage.\n   * @default `JSON.parse`\n   */\n  deserialize?: (cachedString: string) => MaybePromise<PersistedClient>\n\n  retry?: AsyncPersistRetryer\n}\n\nexport const createAsyncStoragePersister = ({\n  storage,\n  key = `REACT_QUERY_OFFLINE_CACHE`,\n  throttleTime = 1000,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n  retry,\n}: CreateAsyncStoragePersisterOptions): Persister => {\n  if (storage) {\n    const trySave = async (\n      persistedClient: PersistedClient,\n    ): Promise<Error | undefined> => {\n      try {\n        const serialized = await serialize(persistedClient)\n        await storage.setItem(key, serialized)\n        return\n      } catch (error) {\n        return error as Error\n      }\n    }\n\n    return {\n      persistClient: asyncThrottle(\n        async (persistedClient) => {\n          let client: PersistedClient | undefined = persistedClient\n          let error = await trySave(client)\n          let errorCount = 0\n          while (error && client) {\n            errorCount++\n            client = await retry?.({\n              persistedClient: client,\n              error,\n              errorCount,\n            })\n\n            if (client) {\n              error = await trySave(client)\n            }\n          }\n        },\n        { interval: throttleTime },\n      ),\n      restoreClient: async () => {\n        const cacheString = await storage.getItem(key)\n\n        if (!cacheString) {\n          return\n        }\n\n        return await deserialize(cacheString)\n      },\n      removeClient: () => storage.removeItem(key),\n    }\n  }\n\n  return {\n    persistClient: noop,\n    restoreClient: () => Promise.resolve(undefined),\n    removeClient: noop,\n  }\n}\n"],
  "mappings": ";;;AAEO,SAAS,OAAO;AAAC;;;ACKjB,SAAS,cACd,MACA,EAAE,WAAW,KAAM,UAAU,KAAK,IAA0B,CAAC,GAC7D;AACA,MAAI,OAAO,SAAS,WAAY,OAAM,IAAI,MAAM,2BAA2B;AAE3E,MAAI,oBAAoB;AACxB,MAAI,WAAW;AACf,MAAI,cAAc;AAClB,MAAI,cAAc;AAElB,SAAO,UAAU,SAAgB;AAC/B,eAAW;AACX,QAAI,YAAa;AACjB,kBAAc;AACd,WAAO,aAAa;AAClB,YAAM,IAAI,QAAQ,CAAC,SAAS,WAAW,MAAM,QAAQ,CAAC;IACxD;AACA,WAAO,KAAK,IAAI,IAAI,mBAAmB;AACrC,YAAM,IAAI;QAAQ,CAAC,SACjB,WAAW,MAAM,oBAAoB,KAAK,IAAI,CAAC;MACjD;IACF;AACA,kBAAc;AACd,kBAAc;AACd,QAAI;AACF,YAAM,KAAK,GAAG,QAAQ;IACxB,SAAS,OAAO;AACd,UAAI;AACF,gBAAQ,KAAK;MACf,QAAQ;MAAC;IACX;AACA,wBAAoB,KAAK,IAAI,IAAI;AACjC,kBAAc;EAChB;AACF;;;ACDO,IAAM,8BAA8B,CAAC;EAC1C;EACA,MAAM;EACN,eAAe;EACf,YAAY,KAAK;EACjB,cAAc,KAAK;EACnB;AACF,MAAqD;AACnD,MAAI,SAAS;AACX,UAAM,UAAU,OACd,oBAC+B;AAC/B,UAAI;AACF,cAAM,aAAa,MAAM,UAAU,eAAe;AAClD,cAAM,QAAQ,QAAQ,KAAK,UAAU;AACrC;MACF,SAAS,OAAO;AACd,eAAO;MACT;IACF;AAEA,WAAO;MACL,eAAe;QACb,OAAO,oBAAoB;AACzB,cAAI,SAAsC;AAC1C,cAAI,QAAQ,MAAM,QAAQ,MAAM;AAChC,cAAI,aAAa;AACjB,iBAAO,SAAS,QAAQ;AACtB;AACA,qBAAS,MAAM,QAAQ;cACrB,iBAAiB;cACjB;cACA;YACF,CAAC;AAED,gBAAI,QAAQ;AACV,sBAAQ,MAAM,QAAQ,MAAM;YAC9B;UACF;QACF;QACA,EAAE,UAAU,aAAa;MAC3B;MACA,eAAe,YAAY;AACzB,cAAM,cAAc,MAAM,QAAQ,QAAQ,GAAG;AAE7C,YAAI,CAAC,aAAa;AAChB;QACF;AAEA,eAAO,MAAM,YAAY,WAAW;MACtC;MACA,cAAc,MAAM,QAAQ,WAAW,GAAG;IAC5C;EACF;AAEA,SAAO;IACL,eAAe;IACf,eAAe,MAAM,QAAQ,QAAQ,MAAS;IAC9C,cAAc;EAChB;AACF;",
  "names": []
}
